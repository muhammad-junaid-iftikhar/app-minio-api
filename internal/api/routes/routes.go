package routes

import (
	"os"


	"github.com/gin-gonic/gin"
	"github.com/minio/minio-go/v7"
	"github.com/rs/zerolog"
	ginSwagger "github.com/swaggo/gin-swagger"
	swaggerFiles "github.com/swaggo/files"
	_ "github.com/muhammad-junaid-iftikhar/app-minio-api/docs" // docs is generated by Swag CLI
	"github.com/muhammad-junaid-iftikhar/app-minio-api/config"
	"github.com/muhammad-junaid-iftikhar/app-minio-api/internal/api/handlers"
	"github.com/muhammad-junaid-iftikhar/app-minio-api/internal/api/middleware"
)

// @title App Minio API
// @version 1.0
// @description This is the API documentation for the App Minio service.
// @termsOfService http://swagger.io/terms/
// @contact.name API Support
// @contact.url http://www.yourdomain.com/support
// @contact.email support@yourdomain.com

// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @description Type 'Bearer' followed by a space and then your token (e.g., 'Bearer your_token_here')
// @security BearerAuth

// @host localhost:8080
// @BasePath /api/v1
// @schemes http https

// InitSwagger initializes the Swagger documentation
func InitSwagger(router *gin.Engine, minioClient *minio.Client, logger *zerolog.Logger, cfg *config.Config) {
	// Set up Swagger
	swaggerHost := os.Getenv("API_BASE_URL")
	if swaggerHost == "" {
		swaggerHost = "localhost:8080"
	}

	// Set the host in the Swagger info
	scheme := "http://"
	if os.Getenv("APP_ENV") == "production" {
		scheme = "https://"
	}
	// Ensure the host doesn't already include http:// or https://
	if len(swaggerHost) > 7 && (swaggerHost[0:7] == "http://" || swaggerHost[0:8] == "https://") {
		swaggerHost = swaggerHost
	} else {
		swaggerHost = scheme + swaggerHost
	}
	swaggerURL := ginSwagger.URL(swaggerHost + "/swagger/doc.json")
	router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler, swaggerURL))

	// Set up application routes
	setupAppRoutes(router, minioClient, logger, cfg)
}

func setupAppRoutes(router *gin.Engine, minioClient *minio.Client, logger *zerolog.Logger, cfg *config.Config) {

	// Initialize handlers
	minioHandler := handlers.NewMinioHandler(minioClient, logger, cfg)

	// Initialize R2 handler
	r2Handler, err := handlers.NewR2Handler(cfg, logger)
	if err != nil {
		logger.Fatal().Err(err).Msg("Failed to initialize R2 handler")
	}

	// Initialize middlewares
	authMiddleware := middleware.NewAuthMiddleware(logger)
	loggerMiddleware := middleware.LoggerMiddleware(logger)

	// Apply global middlewares
	router.Use(loggerMiddleware)

	// API version group with auth middleware
	v1 := router.Group("/api/v1")
	v1.Use(authMiddleware.Authenticate())
	{
		// Apply auth middleware to all v1 routes
		v1.Use(authMiddleware.Authenticate())

		// File operations
		files := v1.Group("/files")
		{
			// List files
			// @Summary List all files
			// @Description List all files in the MinIO bucket
			// @Tags files
			// @Security BearerAuth
			// @Produce json
			// @Success 200 {array} object
			// @Failure 401 {object} map[string]string
			// @Router /api/v1/files [get]
			files.GET("", minioHandler.ListFiles)

			// Upload file
			// @Summary Upload a file to MinIO
			// @Description Upload a file to MinIO storage
			// @Tags files
			// @Security BearerAuth
			// @Accept multipart/form-data
			// @Produce json
			// @Param file formData file true "File to upload"
			// @Success 200 {object} map[string]string
			// @Failure 401 {object} map[string]string
			// @Router /api/v1/files [post]
			files.POST("", minioHandler.UploadFile)

			// Get file
			// @Summary Get a file
			// @Description Get a file from MinIO by its name
			// @Tags files
			// @Security BearerAuth
			// @Produce octet-stream
			// @Param filename path string true "File name"
			// @Success 200 {file} binary
			// @Failure 401 {object} map[string]string
			// @Router /api/v1/files/{filename} [get]
			files.GET("/:filename", minioHandler.GetFile)

			// Delete file
			// @Summary Delete a file
			// @Description Delete a file from MinIO by its name
			// @Tags files
			// @Security BearerAuth
			// @Produce json
			// @Param filename path string true "File name"
			// @Success 200 {object} map[string]string
			// @Failure 401 {object} map[string]string
			// @Router /api/v1/files/{filename} [delete]
			files.DELETE("/:filename", minioHandler.DeleteFile)
		}

		// Bucket operations
		buckets := v1.Group("/buckets")
		{
			// List buckets
			// @Summary List all buckets
			// @Description List all buckets in MinIO
			// @Tags buckets
			// @Security BearerAuth
			// @Produce json
			// @Success 200 {array} object
			// @Failure 401 {object} map[string]string
			// @Router /api/v1/buckets [get]
			buckets.GET("", minioHandler.ListBuckets)
		}

		// Cloudflare R2 operations
		cloudflare := v1.Group("/cloudflare")
		{
			// R2 Storage operations (protected by auth)
			r2 := cloudflare.Group("/r2")
			{
				// List files in R2 bucket
				// @Summary List files in R2 bucket
				// @Description List all files in the specified Cloudflare R2 bucket
				// @Tags cloudflare,r2,files
				// @Security BearerAuth
				// @Accept json
				// @Produce json
				// @Param request body handlers.ListFilesRequest true "Bucket name"
				// @Success 200 {object} handlers.ListFilesResponse
				// @Failure 400 {object} map[string]string
				// @Failure 401 {object} map[string]string
				// @Failure 500 {object} map[string]string
				// @Router /api/v1/cloudflare/r2/files [post]
				r2.POST("/files", r2Handler.ListFiles)

				// Upload operations
				upload := r2.Group("/upload")
				{
					// Generate presigned URL for direct upload to R2
					// @Summary Generate presigned URL for direct upload to R2
					// @Description Generate a presigned URL that can be used to upload a file directly to Cloudflare R2
					// @Tags cloudflare,r2,upload
					// @Security BearerAuth
					// @Accept json
					// @Produce json
					// @Param request body handlers.GeneratePresignedURLRequest true "Presigned URL request"
					// @Success 200 {object} handlers.PresignedURLResponse
					// @Failure 401 {object} map[string]string
					// @Router /api/v1/cloudflare/r2/upload/presigned-url [post]
					upload.POST("/presigned-url", r2Handler.GeneratePresignedURL)
				}
			}
		}
	}

	// Health check endpoint (public)
	health := router.Group("/")
	{
		// Health check
		// @Summary Health check endpoint
		// @Description Check if the API is up and running
		// @Tags health
		// @Produce json
		// @Success 200 {object} map[string]string
		// @Router /health [get]
		health.GET("health", func(c *gin.Context) {
			c.JSON(200, gin.H{"status": "ok"})
		})
	}
}